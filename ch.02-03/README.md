# 코어측 자바스크립트

## 2장 어휘구조.

> 대소문자 구문 while,While, whilE 모두다 다른 변수이다.
> HTML은 대소문자를 구별하지 않지만 XHTML을 구분한다.
> 유니코드든 뭐든 따로 읽어보고 `\` 이스케이프만 알아두자.
> 정규식,특수문자쓸때 필요하다.


> 지금 쓰는 `//` 한줄 주석

> HTML 태그 안에서는 `<!-- -->`을 사용한다.

>리터럴은 프로그램에 직접 나타나는 데이터값이다.
>쉽게 말하자면 var a = 1; 은 a는 1을 담은 변수값이고 1이 리터럴값이다.
>`{x:1,y:2}` 프로퍼티 x의 리터럴값은 1이다.

>`[1,2,3,4,5]` 배열의 length의 리터럴값은 5이다. 배열의 index[0]의 리터럴값은 1이다.


>식별자의 시작은 알파벳,밑줄(_),혹은 달러($)표시여야한다.
>식별자의 첫글자로 숫자를 쓰지않은건 자주 써보니 숫자를 맨처음에 쓰게해놓으면 진짜 숫자랑 식별자랑 헷갈릴만한 소지가 많을것같다.

>pc에 속한글자도 사용할수있다는데 특별한경우인것같고
>예약어는 한번 살펴보고 자주 쓰다보면 안써야될것들이나 에디터에서 색깔이
>특정언어에서 바뀌는걸 살펴보면 잘 넘어갈수있을것같다.


>### 2.5 선택적인 세미콜론 사용

>그냥 불편하든 안불편하든 뭐든지 끝나는곳에 세미콜론 넣는습관은 꼭 길러야할것같다.

>js를 압축할때 한줄로 만들어버릴때 에러가날수있는데 나는 압축안할건데 뭐 잘동작하는데 꼭 넣을필요가 있을까라고 생각하지말고 아무생각없이 습관을 들이는게 가장중요



## 3장 타입,값,변수

> 맨처음에 설명하고 있는것은 리터럴값등을 계속 활용하고자할때 그 값을 그냥 사용하는게 아니라 특정변수에 담아서 특정변수의 참조를 할수있는 동작방식에대해서 설명하고있다.

> 우리가 잘하는 var a=2; var b=a; b=2가 되는방식인데 왜 이런지 생각해보자면

> 그냥 특정값으로 넘겨버리면 이런형태가 된다. 2=2; 2=2; 2=2;

> 그래서 특별한 변수로 그 값을담아서 참조 할당하는 방식을 넘기는것이라고 보면된다. 나중에 나오겠지만 프로토타입으로 지정된 프로퍼티의 값을 바꾸면 프로토타입 객체들의 값들이 바뀌게 되는데
참조할당이 되어서 모든값이 할당된값을 바라보기 때문이다. 근데 원시값을 바꾸면 그 바꾼 프로토타입 객체값만 바뀌게 되는데 그 값은 할당된 값이 아니기 때문이다.

> 타입은 원시 타입과 객체 타입으로 나뉘는데 원시 타입은 숫자,텍스트(스트링값),불리언(true,false),그리고 특이한값인 null과 undefined가 있다.

> 객체는 이름과 값을 갖는 프로퍼티의 집합이다라고 하는데 특정객체에서 예를들어 `var a ={x:1}`은 a는 변수이자 x프로퍼티 1이란 값을 갖는 객체라고 생각하면된다.

> 즉, `a.x`는 `a`라는 객체는 `x`라는 이름의 프로퍼티를 갖고 있고 `Number값 1`을 갖고있다는 뜻이다.


> 일반적인 자바스크립트 객체는 순서가 없는값들의 집합.

> `ex) var arr = [1,2,3] 배열 arr에서 1번째값은 1 2번째값은 2`

> `var obj = {x:1,y:2,z:3} 객체 obj에서 1번째값은 알수없다.`

> 객체를 length값과 index값이 없는 배열처럼 속일수있지만 배열은 아니다.



>자바스크립트에서 중요한 함수는 특별한객체 객체는 객체인데 함수객체이다. 가장 중요한 점은 함수는 값이고, 우리가 알고있는 객체처럼 사용할 수 있다.
함수는 실행코드(우리가 흔히 부르는 객체의 메소드가 될수있고 함수 그자체가 될수있다.
이 부분은 간단하게 설명했지만 가장 중요한데 객체로 실행되는 함수와 함수 그자체로 실행하는것과는 굉장히 차이가 난다. 그래서 객체지향언어라고 불리는것도 다른점을 이해한후에야 피부로 와닿는것같다.)

>새로 생성된 함수객체를(여러가지로 초기화 시킬수있는데 이 초기화는 this라는 기본적으로 window 'use strict'에선 undefined로 나오기 때문에 초기화가 중요하다.)
함수객체를 초기화를 시키지 않으면 각 함수의 컨스트럭터가 생성되어 지지않아 함수중괄호안의 실행코드에 접근할수없다.


>new라는 생성자 함수로 객체를 초기화

>call,apply로 this값을 객체값으로 초기화
        
>함수의 특정 메소드값으로 호출하여 객체값으로 초기화

>함수 내부의 특정 변수에 객체값을 받아 리턴값으로 변수값을 나타낸뒤에 그값을 받아 초기화 하는 방법이 있다.


>객체지향언어라고 나오는 예제 a.sort()가 sort(a)의 객체 지향버전이라고 나오는데 객체지향이기 때문에 배열 a를 함수안에 인자로 넣어서 sort시키는것이 아닌 a란 배열의 객체를 가지고 sort를 시킨다는 점에서 객체지향언어라고 불리운다.

>자바스크립트의 타입은 크게 `원시타입(number,string,boolean,null,undefiend)`

>`객체타입(object,function,array,regxp,date)`

>여기서 객체 또 메서드를 가진 타입과 그렇지 않은 타입 수정할수있는타입과 수정할수없는 타입이있는데 이런 값들은 천천히 아래에서 살펴보면서 숙지하면 될것같다.

>### 3.1숫자

>다른 프로그래밍 언어들과는 다르게 정수값과 실수값을 구분하지않는다.아래 여러예제들은 읽으면 이해가 가는내용이고 이해가 가지않더라도 뭐 크게 상관없을것같다.

>### 3.2텍스트

>날짜와 시간을 표현하는 객체 Date() 생성자를 제공한다. 숫자처럼 원시타입이 아니라 각 미리 정해진 여러가지 메서드로 값을 받아올수있다.

>### 3.2.1 문자열 리터럴
>그냥 문자열을 사용하려면 작은 따옴표나 큰따옴표로 둘러쌓일수있는데
똑같이 문자열은 만드는건데 왜 두개를 나누었냐면 ''는 ""에 종속될수있고
""는  ''에 종속될수있다. 같은 따옴표를 쓰게되면 +연산자로 변수의 값으로 합칠수있다.


<pre>
    <code>
        var hi = 'hi';
        hi.toUpperCase()
    </code>
</pre>

>'HI'라고 해서 hi가 HI로 변한게 아니라 toUpperCase를 통해 새로운 문자열로 대문자를 반환한것이라고 생각하면된다. 


>### 3.2텍스트

>그냥 참고로 알아두면 정규식의 /^HTML/ 은  첫부분이 HTML으로 시작하는것과 일치
`[1-9][0-9]` 은 이해하기 어렵게 설명해놨는데 []의 정규식 문법은 대괄호사이에 있는 문자와 매칭 1-9니깐 1부터 9까지 매칭되는 값인데 숫자가 처음에 1에서 9사이에 시작하게 매칭을 해놨으니 0이 아닌 숫자와 일치라고 설명해놨는데 `[채식주의자]` -> 배고플때 고기빼고 먹는사람 이렇게 설명한것이랑 비슷한 설명같다. 


>그 다음에 이어지는 아무숫자나 따라온다는뜻은 `[0-9]*`은 정규식에서 *앞에 나오는 패턴은 생략이 가능하거나 그 패턴이 하나이상 나오면 전부다 매칭 숫자가 아무거나 나와도 다 일치하고 안나와도 일치한다.


>var text = "testing : 1,2,3" 간단한 문자열이라고 했는데 얼핏보면 :때문에 프로퍼티 정의로 오해할수있는데 그냥 따옴표안에 갖혀있는 장황한 텍스트들이다.


> `var pattern = /\d+/g`

>끝에 나오는 g는 글로벌 정의 `\d`는 `[0-9]`와 동일하고 뒤에 +는 +앞에 나오는 패턴은 무조건 하나 이상은 매칭되어야한니 숫자한개이상 나오면 모든 숫자와 일치하게 된다는 뜻이다.


>pattern.test(text)

>이제 주목해서 볼건 내가 메소드를 정의하지도 않았는데 pattern객체다음에 .으로 시작하고 괄호사이에 뭔 변수값을 넣어서 실행되는거면 내부 메서드라고 보면 된다.

>test는 정규식의 메서드중하나인데 그냥 매칭이 되는게 있으면 무조건 true를 반환하게 되는데 pattern이 아까 숫자하나 이상으로 시작되면 매칭되는거니 text에 1,2,3숫자가 3개나 있으니 당연히 true값을 반환한다.


<pre>
    <code>
        function reg(spec){
            var that = {};
            var text = spec.text;
            var pattern = spec.pattern || /\d+/g;

            that.get_pattern = function(){
                return console.log(pattern.test(text))
            }

            that.get_search = function(){
                return console.log(text.search(pattern))
            }
            that.get_match = function(){
                return console.log(text.match(pattern))
            }
            that.get_replace = function(){
                return console.log(text.replace(pattern,'#'))
            }
            that.get_split = function(){
                return console.log(text.split(/\D+/))
            }
            return that;
        }


        var yam = reg({text:'testing:1,2,3',pattern:/\d+/g});

        
        console.log(yam.get_pattern())
    </code> 
</pre>

> `text.search(pattern)`

>처음보면 굉장히 골까는 부분인것같다. 아까는 숫자 한개 이상 매칭되는 pattern이란 변수를 테스트 하더니 이제는 문자열 testing: 1,2,3을 가지고 pattern이란 매개변수로 search란 메서드를 실행시킨다니

>정규식에는 정규식패턴을 사용하는 String객체의 메서드가 4개있다.
search,replace,match,split인데 그럼 test는 이라고 설명할텐데 regexp(정규식)객체의 메서드이다. 위에는 정규식객체에서 실행시키는 메서드 인자값은 스트링값을 받는다. test하고 exec가 있는데 test는 아까 설명했고 exec는 좀 복잡해서 나중에 정규식에서 다시 보는게 속편하고 이렇게 장황하게 설명해봤자 다 까먹는다.


> `console.log(yam.get_search())`

> 1. search값은 객체값에서 정규식패턴을 일치할때 그 일치한 위치를 반환하는 값인데 저기는 숫자한개이상이 매칭되는거니깐 9가 반환된다. 왜냐면  t,e,s,t,i,n,g,: 공백이 9이고 숫자하나와 매칭되는 기준점인 1이 9번째부터라서 그렇다. 

<pre>
    <code>          <em>t<sup>1</sup>e<sup>2</sup>s<sup>3</sup>t<sup>4</sup>i<sup>5</sup>n<sup>6</sup>g<sup>7</sup>:<sup>8</sup>1<sup>9</sup></em>
    </code>
</pre>


> `console.log(yam.get_match())`

> 2. match값은 아까 testing : 1,2,3에서 Number값은 1,2,3밖에 없는데 이 값을 배열로 집어넣어 값을 반환한다. [1,2,3]


> `console.log(yam.get_replace())`

> 3. replace는 잘쓰이는 방식중하난데 여기서는 pattern = 즉숫자로 시작한것을 #으로 바꾸게 해놨는데 testing: #,#,#으로 바뀐다.


>`console.log(yam.get_split())`

> 4. text.split은 또 골까게 설명해놨는데 첫번째 인자의 값을 기준으로 매칭되는값만 나누는것인데 배열에 담는다. /\D+/는 숫자와 ASCII문자 빼고 모든값인데 그래서 저기에서 값이 공백하나 1,2,3이 출력되는것이고, 두번째 인지값은 legth지정하는것이다. 1이면 매치되는 첫번째값만 출력이 되어버린다.

<pre>
    <code>
            that.get_split = function(){
                return console.log(text.split(/\D+/), 1) 이런식으로
            }
    </code>
</pre>


> ###3.3 불리언값

>그냥 불리언값은 참/거짓을 뜻하는 true/false이다.
true는 1과 동등하고 false는 0값과 동등하다.
null과 undefined는 조건식에서 true랑 같지 않아서 else값으로 넘어가는거지  false값이랑 똑같아서 true가 아니기 때문에  else값으로 넘어가는것으로 혼란을 일으키면 안된다.


<pre>
    <code>
            if(null == 0){
                alert('null이 0이야?')
            }else if(null == false){
                alert('null이 false야?')
            }else{
                alert('null은 null이나 undefined랑 비교해야지')
            }
    </code>
</pre>


> 불리언 값은 문자열 'true' 혹인 'false'로 변환할 수 있는 toString()메서드를 가지고 있지만 그 밖의 메서드는 가지고 있지않다. 

> 여기서 또 단순하지 않은 &&와 ||연산자를 진짜 쉽게 설명하고 있다. 4.10에서 자세히 설명한다는데 그냥 여기서 설명 더 자세히 먼저 보고 아래를 클릭하여 살펴보자.

[4.10 논리표현식](./ch.04/README.md#410-논리-표현식)


> `if((x==0 && y == 0) || !(z==0))` { x와 y는 둘다 0이거나 z가 0이 아니다}
 이걸 자세히 풀어보자면 &&의 값은 좌변값이 false이면 오른쪽값은 평가도 하지않고 false값을 갖게 된다. 일단 x가 0이 되면 y값으로 넘어가게 되는데 이놈도 0이아니면 이 &&식은 true가 되고 아니면 또 false값을 반환하게 된다. 이 값이 또 하나의 좌변값으로 쓰이게 됐는데 || 연산은 이 좌변식이 true이면 오른쪽으로 갈 필요없이 true를 반환한다 x랑 y가 둘다 0이면 z가 0이든 1이든 10000이든 상관이 없다. 근데 좌변값에서 x가 0이 아니게 되면 바로 오른쪽식으로 평가가 들어가서 z가 0이아니면 이 식은 참조건을 만족해서 조건식이 평가되고 z가 0이면 그냥 조건식이 실행되지않는다. 앞에 !는 !뒤에나오는 식을 불리언값으로 반대값으로바꿔놓는것이라고 생각하면된다.


> ###3.4 null과 undefined


> null은 값이없음 변수에 빈문자열을 할당했을때 나타나고 typeof연산자를 쓰면 object를 반환한다.

> undefined는 null가 달리 빈값이 아니라 그냥 값이 없을때 나타나는데 변수를 초기화 시키지않았거나 존재하지 않는 객체의 프로퍼티나 배열의 원수값 반환값이 없는 함수와 인자가 없는 함수 매개변수의 값에 의해 반환하는데 조금 위험하게  생각하면 값도 없는데 불러오면 다 undefined라고 생각하면 될것같다. undefined는 typeof연산자를 사용할때 undefined가 반환되는데 그냥 undefined는 그 값 자체로 특별한 고유의 값이라고 생각하면 될것같다.

>둘의 차이에도 불구하고 값이 없는것은 같기때문에 동등연산자로는 true를 반환하게 되고 false로 판정되는 값이며 !null과 !undefined로 불리언값으로 변환하면 false를 반환한다.


> ###3.5 전역객체

>자바스크립트 인터프리터가 시작할때(웹브라우저가 새로운 페이지를 불러올때) 새로운 전역객체를 만들고 그 프로퍼티를 초기화한다.
여기서는 전역객체가 생성되고 프로그램 전역에서 사용될 몇 가지 값들이 객체에 추가되는 프로그램에서 정의한 전역 객체를 가진다고 설명이 되어있는데 그냥 console을 찍어봐서 window에 어떤것들이 정의되어있는지 살펴보면 그냥 무난하게 넘어가지 않을까 싶다.


<pre>
    <code>
        var global = this;
        console.log(global.outerHeight)
        console.log(window.outerHeight)
    </code>
</pre>


> ###3.6 레퍼 객체

>자바스크립트 객체는 복합적인 값이고, 객체 안의 값들은 프로퍼티 또는 이름이 있는 값들의 집합이며 표기법을 사용하여 객체다음 . 객체['프로퍼티']값을 참조하고 프로퍼티의 값이 함수일때, 이 프로퍼티에서 불리워지는 함수를 메서드라고 부른다.



<pre>
    <code>
        var s = "hello world!"
        var word = s.substring(s.indexOf('')+1, s.length);
        
        console.log(word)
    </code>
</pre>


>왜 문자열은 원시값이라고 위에서 그렇게 말했으면서 프로퍼티와 메서드를 가지고 있을까?
문자열 s의 프로퍼티나 메서드를 참조하려고 할 때, 자바스크립트는 new String(s)을 호출한 것처럼 문자열 값을 객체로 변환한다. 이 객체는 문자열 메서드를 상속 하고 프로퍼티 참조를 살펴보는데 사용한다.

[6.2.2 상속](./ch.04/README.md#622-상속)


>s의 프로퍼티를 참조할때 문자열값을 객체로 변환
s.substring()을 참조하게 된다면 s는 새로운 문자열을 갖는 객체로 변환
객체의 기존 substring()메서드는 없으니 s.prototype.substring = function(){}
저런 방식으로 참조할때 값이 나오면 이 일말의 과정은 값을 내놓고 메모리에서 회수되는 방식으로 되는것같다.


<pre>
    <code>
        var beforeString = "test";
        beforeString.len = 4
        console.log(beforeString.len = 4) 
        
        이 단계는 beforeString.len에 4가 담겼다는 것을 console창에 보여주기 위함이다.
    </code>
</pre>

