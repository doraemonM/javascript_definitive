# 4장 표현식과 연산자

>표현식은 인터프리터를 통해 값으로 평가되는 자바스크립트의 구문이다. 라고 어렵게 설명해놨는데 뭐 프로퍼티는 객체다음에 .으로 배열은 []으로 메소드는 .다음에 함수식이니깐 ()로 함수는 ()로 평가되는 막상 말로 표현식이 이런거다 말고 이런 식으로 설명하면 더 알아듣기 쉬울것같다.

> ## 4.1 원시 표현식

>가장 간단한 형태의 표현식은 '원시 표현식으로' 다른 표현식을 포함하지 않은 그 자체 상수나 리터럴값또는 특정언어 키워드들 변수참조등

>저기서 다 읽다 보면 this 현재객체로 평가된다라고 막연하게 써놓고 막상 우리가 this쓰면 전역객체 바라보고 있고 왜 내부에서 this썼는데 오류나고 있는지 짜증날텐데 내부함수에서 this쓰면 window객체를 바라보는것이 맞다.

<pre>
  <code>
    var a = "hi";

    function fn(a){
        return console.log(this.a)
     }

     function Fn(a){
       this.get_a = function(){
           return console.log(a)
       }
     }

     var x1 = new Fn('hello');   

     fn()          
     x1.get_a();
  </code>
</pre>

> 3장 마지막에 여러분이 전역 자바스크립트 변수를 선언할때 실제로는 전역 객체의 프로퍼티를 정의하는것이다. 이 말이 있는데 저 fn()함수와 Fn()함수의 근본적인 차이는 fn()의 a인자값은 평가되지않고 그냥 window.a 프로퍼티값을 바로 반환해주고있으며 Fn()함수는 this값을 new생성자로 this를 자신을 바라보게 하면서 get_a의 메소드를 실행시켜서 a값을 자신의 값으로 나오게 하는 this는 간단하게 살펴보면 간단하지만 기본 동작 개념을 장착하지 않으면 한없이 헷갈릴수밖에 없는것같다.

>저렇게 this키워드는 각기 다른 값으로 평가되고 "객체지향프로그래밍"에서 주로 사용된다. 메소드의 본문 안에서 this는 메서드를 호출한 객체로 평가된다.

>1. 원시 표현식에서 값그자체 리터럴값 (특이점 정규표현식리터럴)
>2. 키워드 원시표현식 true,false,null,this
>3. 변수를 있는 그대로 참조 var다음의 값 ( 특이점 undefined는 키워드가 아닌 변수로 취급)


> ## 4.2 객체와 배열의 초기화 표현식

>객체와 배열 초기화 표현식은 말 그대로 새로운 객체나 배열을 값으로 하는 표현식이다. 이들 초기화 표현식은 '객체 리터럴' '배열리터럴' 이라고 불리는데 일반 리터럴과는 달리 원시표현식이 아니다.

>3장에서 보면 값받아오는 방식을 이해했다면 이말뜻이 이해가 갈것이다.

>그냥 쭉 읽다보면 이해가 갈것인데 마지막 원소 표현식 다음에 쉼표가 올 수는 있지만 값이 정의되지 않은 원소를 생성하지않는다는 `var ok = [1,2,3,]` 배열 ok의 length는 3이고 index값0은1 1은2 2는3 3의 인덱스는 빈값이 아닌 생성되지 않는다는 뜻이다.

>객체 초기화 표현식은 배열 초기화 표현식과 유사하고 대괄호가 아닌 중괄호가 사용되고 각 표현식에는 프로퍼티 이름과 값을 받는 콜론이 위치한다.

>배열,객체 초기화는 객체가 초기화 될때마다 매번 평가되기 때문에 일정한 값을 갖지 않는다라는 말은 그냥 값이 바뀌면 매번 값이 바뀌는대로 표현는것을 표현한것같다.

<pre>
  <code>

        function objectNew(){
            var that = {}
            that.props = function(x,y){
                return console.log(x + y);
            }
            return that;
        }

        var newOb = objectNew();

        newOb.props(3,5);
        newOb.props(4,8);
  </code>
</pre>

>좀 다른 의미로 표현하긴 했지만 이런식으로 newOb.props의 값은 정해져있지않다. 그냥 똑같은 값을 매번불러와도 그 의미가 일정한 값을 같는게 아니라 다른값을 넣으면 언제든 바뀔수있다는 부분을 이해하는것이 좋을것같다.


> ## 4.3 함수 정의 표현식

>함수 정의 표현식은 함수를 정의하고, 함수 정의 표현식의 값은 함수가 된다. 다시 말해, 함수 정의 표현식은 '함수 리터럴'이라 할 수 있다.

>책을 읽을때마다 번역에 초점을 둔것인지 직역을 해놓고 우리나라말처럼 번역을 해놓은건지 모르겠지만 각설하고


<pre>
  <code>
    일부러 전역에 함수 정의하지않기 위해서 함수호출식을 바꿈

    function square(x){
            return console.log(x*x);

    }

    square(8);
    var square = square(16)
  </code>
</pre>

>+ 함수 정의 표현식은 square라는 함수식으로 정의하고
>+ 표현식의 값은 인자x의 제곱으로 나타내는 함수 정의를 만들었는데
>+ 저 리터럴 값은 각각 8일때는 64 16일때는 256이 리터럴값이라고 할수있겠다.
>+ 저 리턴값이 없으면 저 리터럴값은 자동적으로 함수는 undefined를 반환하기 때문에 undefined가 될것이다. 이건 8장에서 다룬다니 좀 기다리자.


> ## 4.4프로퍼티 접근 표현식
