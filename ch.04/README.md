# 4장 표현식과 연산자

>표현식은 인터프리터를 통해 값으로 평가되는 자바스크립트의 구문이다. 라고 어렵게 설명해놨는데 뭐 프로퍼티는 객체다음에 .으로 배열은 []으로 메소드는 .다음에 함수식이니깐 ()로 함수는 ()로 평가되는 막상 말로 표현식이 이런거다 말고 이런 식으로 설명하면 더 알아듣기 쉬울것같다.

> ## 4.1 원시 표현식

>가장 간단한 형태의 표현식은 '원시 표현식으로' 다른 표현식을 포함하지 않은 그 자체 상수나 리터럴값또는 특정언어 키워드들 변수참조등

>저기서 다 읽다 보면 this 현재객체로 평가된다라고 막연하게 써놓고 막상 우리가 this쓰면 전역객체 바라보고 있고 왜 내부에서 this썼는데 오류나고 있는지 짜증날텐데 내부함수에서 this쓰면 window객체를 바라보는것이 맞다.

<pre>
  <code>
    var a = "hi";

    function fn(a){
        return console.log(this.a)
     }

     function Fn(a){
       this.get_a = function(){
           return console.log(a)
       }
     }

     var x1 = new Fn('hello');   

     fn()          
     x1.get_a();
  </code>
</pre>

> 3장 마지막에 여러분이 전역 자바스크립트 변수를 선언할때 실제로는 전역 객체의 프로퍼티를 정의하는것이다. 이 말이 있는데 저 fn()함수와 Fn()함수의 근본적인 차이는 fn()의 a인자값은 평가되지않고 그냥 window.a 프로퍼티값을 바로 반환해주고있으며 Fn()함수는 this값을 new생성자로 this를 자신을 바라보게 하면서 get_a의 메소드를 실행시켜서 a값을 자신의 값으로 나오게 하는 this는 간단하게 살펴보면 간단하지만 기본 동작 개념을 장착하지 않으면 한없이 헷갈릴수밖에 없는것같다.

>저렇게 this키워드는 각기 다른 값으로 평가되고 "객체지향프로그래밍"에서 주로 사용된다. 메소드의 본문 안에서 this는 메서드를 호출한 객체로 평가된다.

>1. 원시 표현식에서 값그자체 리터럴값 (특이점 정규표현식리터럴)
>2. 키워드 원시표현식 true,false,null,this
>3. 변수를 있는 그대로 참조 var다음의 값 ( 특이점 undefined는 키워드가 아닌 변수로 취급)


> ## 4.2 객체와 배열의 초기화 표현식

>객체와 배열 초기화 표현식은 말 그대로 새로운 객체나 배열을 값으로 하는 표현식이다. 이들 초기화 표현식은 '객체 리터럴' '배열리터럴' 이라고 불리는데 일반 리터럴과는 달리 원시표현식이 아니다.

>3장에서 보면 값받아오는 방식을 이해했다면 이말뜻이 이해가 갈것이다.

>그냥 쭉 읽다보면 이해가 갈것인데 마지막 원소 표현식 다음에 쉼표가 올 수는 있지만 값이 정의되지 않은 원소를 생성하지않는다는 `var ok = [1,2,3,]` 배열 ok의 length는 3이고 index값0은1 1은2 2는3 3의 인덱스는 빈값이 아닌 생성되지 않는다는 뜻이다.

>객체 초기화 표현식은 배열 초기화 표현식과 유사하고 대괄호가 아닌 중괄호가 사용되고 각 표현식에는 프로퍼티 이름과 값을 받는 콜론이 위치한다.

>배열,객체 초기화는 객체가 초기화 될때마다 매번 평가되기 때문에 일정한 값을 갖지 않는다라는 말은 그냥 값이 바뀌면 매번 값이 바뀌는대로 표현는것을 표현한것같다.

<pre>
  <code>

        function objectNew(){
            var that = {}
            that.props = function(x,y){
                return console.log(x + y);
            }
            return that;
        }

        var newOb = objectNew();

        newOb.props(3,5);
        newOb.props(4,8);
  </code>
</pre>

>좀 다른 의미로 표현하긴 했지만 이런식으로 newOb.props의 값은 정해져있지않다. 그냥 똑같은 값을 매번불러와도 그 의미가 일정한 값을 같는게 아니라 다른값을 넣으면 언제든 바뀔수있다는 부분을 이해하는것이 좋을것같다.


> ## 4.3 함수 정의 표현식

>함수 정의 표현식은 함수를 정의하고, 함수 정의 표현식의 값은 함수가 된다. 다시 말해, 함수 정의 표현식은 '함수 리터럴'이라 할 수 있다.

>책을 읽을때마다 번역에 초점을 둔것인지 직역을 해놓고 우리나라말처럼 번역을 해놓은건지 모르겠지만 각설하고


<pre>
  <code>
    일부러 전역에 함수 정의하지않기 위해서 함수호출식을 바꿈

    function square(x){
            return console.log(x*x);

    }

    square(8);
    var square = square(16)
  </code>
</pre>

>+ 함수 정의 표현식은 square라는 함수식으로 정의하고
>+ 표현식의 값은 인자x의 제곱으로 나타내는 함수 정의를 만들었는데
>+ 저 리터럴 값은 각각 8일때는 64 16일때는 256이 리터럴값이라고 할수있겠다.
>+ 저 리턴값이 없으면 저 리터럴값은 자동적으로 함수는 undefined를 반환하기 때문에 undefined가 될것이다. 이건 8장에서 다룬다니 좀 기다리자.


> ## 4.4프로퍼티 접근 표현식

>프로퍼티 접근 표현식은 객체의 프로퍼티나 배열의 원소값으로 평가된다.

>1. 표현식.식별자
>2. 표현식[표현식]

>첫 번째 프로퍼티 접근 방법은 표현식에 식별자를 점(.)으로 연결한 표현식이다. 여기서 표현식은 객체(함수,배열 뭐 등등)을 말하고, 식별자는 앞에서 지정한 객체에서 찾고자 하는 프로퍼티의 이름을 의미한다.

> 두번째 프로퍼티 접근방법은 객체나 배열이 되는 첫 번째 표현식에 두번째 표현식을 쓰는건데 이걸또 '열린 대괄호와 두번째 표현식 그리고 닫힌 대괄호를 사용하는 것이다.'라고 써놨는데 이 책은 읽을때마다 일일히 설명안할걸 설명해서 어렵게 받아들이게 하고 설명할건 또 간단히 설명해놓는 경향이 있다.

>각설하고 그냥 객체에선 대괄호값에 쉼표로 프로퍼티값을 감싸면 값을 반환하고
>배열은 index값이 저장되어있으니 그냥 넘버값으로 하면 호출하는것같다.


<pre>
  <code>
      function callProperty(){
          var object = {x:1,y:{z:3}};

          변수 'object'는 객체로 초기화됐고 프로퍼티 x와 y값을 가지고 있고 프로퍼티x는 1의값을 가지고 있고 y는 또 3의값을 가지고 있는 z프로퍼티를 정의하고있다.

          var array = [object,4,[5,6]]

          배열 'array'는 배열로 초기화됐고 legnth값은 3개   index는 0부터 2까지 인덱스 0은 '변수 object를 담고있고' 인덱스1은 단순 리터럴4값 인덱스2는 배열을 또 정의하고 있는데 array의 인덱스 2의 인덱스0의 값은 5 인덱스 2의 인덱스1의 값은 6을 정의하고 있다.

          console.log(object.x);
          console.log(object.y.z);
          console.log(object['x']);
          console.log(array[0].x)

          인덱스0의 object의 프로퍼티 x를 불러왔다.

          console.log(array[0]['x'])
          console.log(array[1])          
          console.log(array[2]['1'])

          여기서 세번째 표현식엔 쉼표도되고 그냥 숫자도 되는걸 보니 toString이나 valueOf로 값을 가져와서 연산자로 값을 반환하는것같다.

          만약 객체가 아니고 그냥 원시값이면 객체로 바뀌고(레퍼객체 3.6참고)하고 프로퍼티값을 불러온다.

          '.식별자' 문법은 두 프로퍼티 접근 방법 중 간단한 형태이지만 객체에 해당 식별자를 이름으로 하는 프로퍼티 이름이 있을때만 사용할 수 있고, 프로그램을 작성할 때 식별자를 알고 있어야한다. 만약 프로퍼티 이름이 예약어이거나 구두 문자나 공백을 포함한 경우나, 숫자(배열의 경우) 일때는 반드시 대괄호 표기법을 사용해야 한다.
      }

      callProperty();
  </code>
</pre>

> ## 4.5 호출 표현식

>호출 표현식은 그냥 () / call,apply /.method()등 함수나 메서드를 호출 또는 실행시키는 값이 있을땐 호출 값을 나타내는 연산이나 일련의 동작일땐 실행

<pre>
  <code>
      function returnWhat(){
          var that = {};

          that.f = function(a){
              return console.log('당신은 '+a+'등입니다.')
          }

          that.nuMax = function(x,y,z){
              return console.log(Math.max(x,y,z))
          }

          that.sort = function(){
              return console.log(that.f(55));
          }

          return that
      }


      var return1 = returnWhat();

      return1.f(3);    
      return1.nuMax(2,3,155)
      return1.sort();
  </code>
</pre>

>처음의 f는 인자값a로 표현되는 인자표현식이다
>두번째는 x,y,z의 3개를 인자값으로 받는데 4개이상의 값을 받으면 무시된다.
>세번째는 뭐 똑같은데 메소드 f를 sort의 함수에서 불러오는것인데 막간 간단 클로저 예제를 사용했다.

>호출 표현식이 평가될때 함수표현식이 가장 먼저 평가되고, 그 후에 호출 인자 표현식이 순서대로 인자 값으로 평가된다. 인자값이 평가된 다음에는 함수 선언시에 지정했던 인자 이름으로 인자 값이 차례로 할당되고, 마지막으로 함수의 본문이 실행된다.

>return1.f(3)일때 return1.f()가 먼저 평가되고(이값이 없으면 당연히 에러를 배출할테니 처음에 존재여부를 평가하는듯싶다.) 3은 인자값으로 평가되고 이 값이 아래 +a+로 할당되고 이제 함수가 값을 뱉어내던지 이벤트가 있으면 이벤트가 실행된다던지의 일련의 과정을 설명하는것같다.

>함수가 값을 반환하지않으면 함수 표현식의 값은 undefined 반환하면 그값을 반환하고 모든 호출 표현식은 ()안의 표현식으로 이루어지고 프로퍼티 표현식이면 메서드 호출 그냥 말을 어렵게 써놨지만 우리가 3장에서 다 다루었던것이다. 또 중요한 키워드를 하나 거론했는데 메서드가 호출되면 함수의 몸체가 실행되는 동안 프로퍼티 접근 표현식이 가르키는 객체나 배열이 모두 this의 매개변수가 된다라고 했는데 이 개념은 아주 중요하니 3장에서 되씹어보고 여기서도 되씹어보자.


> ## 4.6 객체생성표현식

>객체 생성 표현식은 새 객체를 생성하고, 생성자 함수를 호출해 객체에 속한 프로퍼티들을 초기화한다.

>책에 있는말을 그대로 쓸때마다 이 책을 처음 봤던 나는 도대체 이걸 어떻게 이해했을까라고 한번쯤 생각하게 된다. 각설하고 객체 생성 표현식은 new키워드가 앞에 붙는다음점을 제외하면 호출 표현식과 유사하고 3장에서 레퍼객체의 예시를 들었을때 처음 소개됐다.

>`new Number()`
>`new Date` 객체의 생성자 함수를 전달인자 없이 호출할 때, 다음과 같이 괄호를 생략할수있다.

>객체 생성 표현식이 평가될 때, 자바스크립트 인터프리터는 먼저 새로운 빈객체를 생성하고, 이 객체는 객체초기자 {}에 의해 생성되는 객체와 동일하다. 이말이 그냥 새객체를 정의한다는 뜻이다.

>다음으로 지정된 생성자 함수를 호출하여 명시된 전달인자들을 전달하고, 방금 생성된 새 객체로 this키워드를 통해 전달하기 때문에 new로 생성자함수로 호출할때 this가 바로 이 새로 초기화된 객체를 바라보기때문에 this가 여기를 바라보게 되는것이다. 근데 특정 객체값을 반환할 경우 이 값이 생성표현식의 값이 되는데 내가 위에서 that으로 값을 반환하고 new없이 메소드를 실행시키는 경우가 이런식이다.

> ## 4.7 연산자 살펴보기

>공부하면서 혼동하고 쉽게 여겼던 부분인데 가장 오해해하고 있었던 부분같다.
>대부분의 연산자가 +와 =와 같은 문장 부호로 표현되지만, 일부는 delete와 instanceof와 같이 키워드로 표현하는데, 문장 부호 연산자와 비교해 좀더 읽기 쉽고 덜 간결한 형태로 표현된 것 뿐이다.

>표 4-1은 연산자 우선순위를 기준으로 정렬되었는데 목록에 나열된 연산자들 중에서 첫번째 소개된 연산자가 나머지 연산자와 비교했을때 우선순위가 가장높고, 결합방향등을 좀 자세히 살펴볼 필요가있다. 그리고 우리가 연산자인지 모르고 넘어갔던것들도 몇개있으니 숙지 하도록하자

> ### 4.7.1 피연산자 개수

>연산자에 필요한 피연산자의 개수에 따라 연산자들을 분류할 수 있는데 곱셈 연산자 `*`처럼 자바스크립트 연산자 대부분은 2항연산자이고 3항 연산자도 지원하는데 조건부 연산자 ?:이다.

> ### 4.7.2 피연산자와 반환타입

>일부 연산자는 값의 타입과 무관하게 동작하지만 실제로 대부분의 경우에는 피연산자 타입이 정해져 있다. 그리고 대체로 연산자들은 특정 타입의 값을 반환(또는 평가한다.)

>`console.log(1>2)` false를 반환한다.

>저기에서 자바스크립트에서 모든값은 참으로 평가되거나 거짓으로 평가되는데 불리언값을 피연산자로 갖는 연산자는 피연산자 타입과 무관하게 동작한다.

<pre>
  <code>
      function booleanFalse(){
          var x = new Boolean(false);
          if(x){
              return console.log(x.valueOf());
          }
      }

      booleanFalse();
  </code>
</pre>

>booleanFalse()라는 함수에서 x의 변수에 생성자 함수 Boolean(false)에 담았다. x의 값은 false이라면 저 함수는 실행되지 않았는데 false를 리턴한다. 바로 이 이야기다 불리언값을 저기선 false값을 피연산자로 갖지만 값자체가 있기때문에 참이다. (x의 값은 false지만 if문에서 x가 값을 가지고 있는지 안가지고 있는지가 true,false를 판단하는것이다)

>여기 설명한게 헷갈린다 그러면 3장을 다시 정독해보는게 좋을것같다.


> ### 4.7.4 연산자 부수 효과


>`2*3`과 같은 간단한 표현식은 절대 결과가 달라지지 않고, 앞으로의 결과도 항상같다. 하지만 일부 표현식은 부수효과를 갖는데 이러한 효과는 표현식이 다시 평가될 때 기존의 값에 영향을 미치게 된다.

>할당 연산자가 대표적인 경우인데, 변수나 객체의 프로퍼티에 값을 할당하면 변수나 프로퍼티를 사용한 모든 표현식의 값을 바꾼다.

>변수나 객체의 프로퍼티에 값을 할당하면 변수나 프로퍼티를 사용한 모든 표현식의 값을 바꾸고 이와 유사하게 증가 연산자 ++와 감소 연산자--도 실행되면 기존의 값을 변경하는 묵시적 할당이 이루어지고, delete연산자도 프로퍼티를 삭제하면 undefined값을 할당하는것과 유사하다는데

<pre>
  <code>
      var pro = {x:1,y:2};
      pro.z = 3;

      delete pro.z  ==  pro.z = undefined

       pro.z에 undefined를 할당하는것처럼 pro.z를 호출하면 undefined를 호출하는것때문에 이런 설명이 나오는것 같다
  </code>
</pre>

> ### 4.7.5 연산자 우선순위

>프로퍼티 접근이나 호출 표현식은 표4-1에 나열된 연산자들보다 항상 우선순위가 높다.

>typeof연산자가 우선순위가 높지만 프로퍼티접근과 함수호출이 끝난 후에야 실행된다. 그래야지 typeof부터 실행하면 값이 개판될것같다. my객체 불러오고 object잡고 function메소드의 x프로퍼티불러오고 그다음에 y인자값 평가하고 여튼 이런 일말의 과정때문에 그런것같다.

>중요한 규칙은 할당은 우선순위가 낮다는것과 대부분 마지막에 수행된다는 점을 인식하는것이 가장 중요하다.

> ### 4.7.6 연산자 결합방향(4.7.6워프)

>표 4-1에서 "A"라고 표시된 열은 연산자 결합 방향을 지정한다고 설명했다.

>뺄셈은 L(왼쪽에서 오른쪽이기 때문에)
>w=((x-y)-z) 이런식으로 x와 y부터 연산을 하고 그다음에 맨 우변값을 뺀다.

>여기서 또 중요한게 3항연사자가 나오는데 값이 평가되는 프로세스는 오른쪽부터 왼쪽이기 때문에 약간헷갈릴수가 있을텐데 이건 많이 쓰다보면 그냥 숙달이 되서 자연스럽게 쓸수있게 된다. 이건 말로 설명해봤자 그냥 머리로만 넘길수밖에 없다.

> ### 4.7.7 평가순서

>연산자 우선순위와 결합 방향은 복잡한 표현식에서 어떤 연산이 우선적으로 수행되는지를 결정한다. 하지만 어떤 부 표현식이 먼저 평가되는지를 정하지 않는다. 예를 들어 표현식 w=x+y*z경우에는 w,x,y,z가 차례대로 평가하지만 값은 y랑z곱하고 x랑 더한뒤에 비로소 w를 가리키는 변수나 '객체 프로퍼티'로 값을 할당한다. 여기서 변수에만 값을 할당한다고 1차원 적인 생각을 하면 안된다.

> ## 4.8 산술 표현식

>이번 절에서는 피연산자들의 산술 연산이나 기타 수치조작을 하는 연산자에 대해 다룬다. 곱셈,나눗셈,뺄셈연산자는 매우 직관적이고, 덧셈 연산자는 단순히 우리가 알고 있는 덧셈 연산 뿐 아니라 문자열을 이어 붙일 수도 있고, 피연산자의 타입을 바꿀수도 있어 별도의 절에서 다룬다고한다.

>자바스크립트에서는 모든 숫자는 부동소수점 숫자로 취급된다. 그래서 5/2는 2가 아니라 2.5로 평가된다.

> %연산자는 첫번째 피연산자에 대한 두번째 피연사자의 나머지 연산을 수행한다. 5%2의 결과는 1이고 -5%2의 결과는 -1이다.
> 일반적으로 나머지 연산자는 정수타입의 피연사자에 대해 사용되지만 부동소숫점도 적용된다. 6.5%2.1의 결과는 0.2이다.


> ### 4.8.1 덧셈연산자 +

>+연산자가 이항 연산자로 사용될때 피연산자의 숫자값을 더하거나 문자열을 이어붙인다.
>숫자대 숫자 문자대 문자는 명확하게 연산이 되지만 다른경우에는 타입변환을 일으킨다. +연산자는 타입변환시에 문자열 이어붙이기를 우선으로 수행한다. 그래서 하나의 피연산자가 문자이고 문자열로 바꿀수있는 객체라면 다른 피연산자를 문자열로 변환한우 이어붙인다. 덧셈은 두 피연산자값이 모두 문자열이 아니거나 문자열로 변환될수없을때 수행된다.

>1. 하나의 피연사자값이 객체라면 3.8.3절에 설명한 알고리즘을 이용해 객체를 원시타입으로 바꾼다. 대부분의 객체는 valueOf()메서드를 가지고 있지 않지만 toString 메서드를 가지고 있어 쉽게 문자열로 바뀐다.

>2. 피연산자가 문자열이면 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어붙인다.

>3. 이외의 경우에 두 피연산자가 숫자(또는 NaN)로 변환되고 덧셈연산이 수행된다.

> ### 4.8.2 단항 산술 연산자

>+ +4
>+ -4
>+ ++4
>+ 4++
>+ --4
>+ 4--

>단항 연산자는 하나의 피연산자의 값을 수정해서 새값으로 만든다. 자바스크립트에서는 단항 연산자가 가장 우선순위가 높고, 결합 방향은 모두 오른쪽에서 왼쪽으로이다. 산술 단항 연산자(+,-,++,--)는 이번절에서 소개했듯이 하나의 피 연산자를 가능한 한 숫자 타입으로 변환하려 시도한다. 느낌표(!)문자와 +,=은 단항과 이항 연산자 양쪽에 동시에 사용할수있다.

>단항덧셈(+) 연산자는 피연산자를 숫자(또는NaN)로 바꾼 후 값을 반환

>단항뺄셈(-) 연산자는 피연산자를 가능하면 숫자로 변환하려고 시도하고 성공하면 부호의 값을 바꾼다.

>증가(++) ++연산자는 단항 피연산자에 대해 증가 연산을 한다.(즉, 1을 더한다.) 이때 피연산자는 반드시 좌변 값(변수, 배열 원소 또는 객체 프로퍼티 중 하나)이어야 하고 이러한 변수,원소,프로퍼티가 숫자가 아닐 경우 일단 숫자타입으로 변환하려 시도한다.

>이 연산자는 어느쪽에 위치해 있는지에 따라 다른데 앞에서 사용될 경우에는 전치증가라고 하고 먼저 '피연산자를 증가시킨 다음 증가된 값'을 결과로 내놓고 피 연산자의 뒤에서 사용될 경우 후치증가라고 하며 마찬가지고 '피연산자를 증가 시키지만'  막상 후치증가를 담은 변수의 결과는 원래의 증가되지 않은 값을 내놓는다.
